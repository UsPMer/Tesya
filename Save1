/*
 모든 출력은 더블 버퍼링 기법을 이용하여 출력하며,
 투명블럭, 이펙트등은 PNG형식으로 투명을 출력하여 작업량을 줄이고,
 이외의 블럭, 배경등은 bmp형식으로 출력한다.
*/
#include <iostream>
#include <fstream>
#include <windows.h>
#include <conio.h>
#include <cstdlib>
#include <ctime>
#include <gdiplus.h> 
#include "resource.h"
#pragma comment(lib, "gdiplus")
#pragma comment(lib,"msimg32.lib")

using namespace std;
using namespace Gdiplus;

//Gdi+ 사용을 위한 초기화
ULONG_PTR gpToken;  // 마지막에 GdiplusShutdown에서 사용하므로 저장필수.
GdiplusStartupInput gpsi; 

#define random(n) (rand()%n); //난수 생성

#define Time2 150
#define Time1 700
#define UP 72
#define ESC 27
#define FIXWID 800 //가로
#define FIXHID 750 //세로 
#define WIDTH 16
#define HIDTH 22

int pat[7][32] = { //블럭 패턴
	{ 0,0, 1,0, 2,0, -1,0, 0,0, 0,1, 0,-1, 0,-2, }, //|
	{ 0,0, 1,0, 0,1, 1,1, }, //ㅁ
	{ 0,0, -1,0, 0,-1, 1,-1,   -1,-1,0,0, 0,1, -1,0,  }, // ㄱㄴ
	{ 0,0, -1,-1, 0,-1, 1,0,   0,0, -1,0, -1,1, 0,-1, }, //역ㄱㄴ
	{ 0,0, 0,-1, 1,0, 2,0,   0,0, -1,0 , 0,-1, 0,-2,   0,0, -1,0, -2,0, 0,1,   0,0, 1,0, 0,1, 0,2 },//|--
	{ 0,0, -1,0, -2,0, 0,-1,   0,0, -1,0, 0,1, 0,2,   0,0, 0,1, 1,0, 2,0,   0,0, 1,0, 0,-1, 0,-2 }, //--|
	{ 0,0, -1,0, 1,0, 0,1,   0,0 ,0,-1 ,0,1, 1,0,   0,0, -1,0, 1,0, 0,-1,   0,0 ,-1,0, 0,-1, 0,1 } // ㅗ┴凸
};

int CantMove = 0;
int Second = 0,DownSecond = 0;
int L = 0 , R = 0, Down=0;
int brickpatnum[7] = { 2,1,2,2,4,4,4 };
int Rand=0,MaxArray=8;
int NRand = 0 , NMaxArray = 0;
int IsRanded = 1;

int Map[HIDTH][WIDTH];
//int x = 180 + 50, y = 60 + 50 원점 == 230, y = 110
int x = 260, y = 80 , XOrig=x, YOrig=y;
int Nx = 520, Ny=50;
int NextColor=0,NowColor=0;
int IsFirst = 0;
int IsKeyDown = 0;
int DeleteLine;

LPCTSTR End = TEXT("응 <- -> <- 넌 끝났어");
HDC hdc, MemDC,NextBDC, hMemDC , BMemDC , OLMemDC, BackBufDC, SagacDC, OldDC, CopyDC, BlackDC, WhenRandDC; //DC
HBITMAP MyBitmap, OldBitmap , BackBitmap , SaveBitmap, CopyBitMap, BlackBitmap; //비트맵 저장 핸들
HBITMAP hBlock, hNextBlock, hBlock2, BackGround, hOlMem, hSagac,hWhenR; //블럭 이미지 저장 핸들
HWND hWnd;
HINSTANCE g_hInst;
BOOL Game_Start; //Game_Start = 0 -> 게임 시작전, 1 -> 시작 
static RECT rt = {0,0,FIXWID,FIXHID};
static RECT Brt = { 50,50,470,650 };

Image* LoadPNG(HMODULE hModule, LPCWSTR ResourceName);
Image* image;
Image* WBimage;

ofstream f;

void Draw_Where();
void IsLose();
void Migrate_Block();
void RightNowSelec();
void Draw_Score();
void CleanLine();
void Draw_AlphaBlock();
void SelectBlock();
int CheckCols();
void CleanAry();
void InsertAry();
void ChAnime(); //캐릭터 애니메이션 구현 함수 
void Draw_Effect();
void Draw_Glass();
void DrawCharacter();
int RandColor();
void InitBoard();
void Draw_Block(int flag);
void DrawNextBlock();
void DrawScreen();
void leftmove();
void rightmove();
void downmove();
void rotate();
int isfull();
void printstage();
void makenewblock();
void printscore();
void testArray();
void Effect();
void WhereBlock();

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
LPCTSTR lpszClass = TEXT("Tetress Alpha ver 0.1");

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdParam, int nCmdShow)
{
	MSG Message;
	WNDCLASS WndClass;
	g_hInst = hInstance;

	/*
	oken인자는 윈도우의 핸들과 유사한 GDI+의 라이브러리 Token. 이 값은 GdiplusShutdown()함수의 인자로 이용됨.
	Input인자는 입력 옵션을 정의하는 GdiPlusStartupInput구조체의 주소, 별도의 옵션이 없다면 Default값이 설정됨.
	Ouput는 초기화 결과 반환. NULL이라면 결과받지 않음.
	*/
	if (GdiplusStartup(&gpToken, &gpsi, NULL) != Ok) { //Gdi+ 초기화
		MessageBox(NULL, TEXT("GDI+ 라이브러리 초기화 불가."),
			TEXT("알림"), MB_OK);
		return 0;
	}

	WndClass.cbClsExtra = 0;
	WndClass.cbWndExtra = 0;
	WndClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
	WndClass.hCursor = LoadCursor(NULL, IDC_ARROW);
	WndClass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	WndClass.hInstance = hInstance;
	WndClass.lpfnWndProc = WndProc;
	WndClass.lpszClassName = lpszClass;
	WndClass.lpszMenuName = NULL;
	WndClass.style = CS_HREDRAW | CS_VREDRAW;
	RegisterClass(&WndClass);

	hWnd = CreateWindow(
		lpszClass,
		lpszClass,
		WS_OVERLAPPEDWINDOW,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		FIXWID, //가로
		FIXHID, //세로
		NULL,
		(HMENU)NULL,
		hInstance,
		NULL
	);
	ShowWindow(hWnd, nCmdShow);

	while (GetMessage(&Message, NULL, 0, 0)) {
		TranslateMessage(&Message);
		DispatchMessage(&Message);
	}
	GdiplusShutdown(gpToken);
	return (int)Message.wParam;
}

////////////////// 메시지 처리 루틴///////////////// 

LRESULT CALLBACK WndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	PAINTSTRUCT ps;

	switch (iMessage) {
	case WM_CREATE: //윈도우 생성시 메세지 
		f.open("c:\\Users\\dsm2017\\Desktop\\Arraytest.txt");
		srand(time(NULL));

		Rand = random(7);
		MaxArray = 8 * (rand() % brickpatnum[Rand] + 1);
		NRand = random(7);
		NMaxArray = 8 * (rand() % brickpatnum[NRand] + 1); //1~ NRand - 1 
		//////// DC 초기화 /////////////
		hdc = GetDC(hWnd);
		MemDC = CreateCompatibleDC(hdc); //CreateCompatibleDC(원본DC): 원본 DC를 복사함.
		hMemDC = CreateCompatibleDC(hdc);
		BMemDC = CreateCompatibleDC(hdc);
		OLMemDC = CreateCompatibleDC(hdc);
		BackBufDC = CreateCompatibleDC(hdc);
		NextBDC = CreateCompatibleDC(hdc);
		SagacDC = CreateCompatibleDC(hdc);
		OldDC = CreateCompatibleDC(hdc);
		BlackDC = CreateCompatibleDC(hdc);
		WhenRandDC = CreateCompatibleDC(hdc);

		CopyDC = CreateCompatibleDC(hdc);

		NowColor = RandColor();
		NextColor = RandColor();

		CopyBitMap = CreateCompatibleBitmap(hdc, FIXWID, FIXHID);
		SelectObject(CopyDC, CopyBitMap);
		//FillRect(CopyDC, &Brt, (HBRUSH)GetStockObject(WHITE_BRUSH));
		SaveBitmap = CreateCompatibleBitmap(hdc, FIXWID, FIXHID);
		BackBitmap = CreateCompatibleBitmap(hdc, FIXWID, FIXHID);
		OldBitmap = (HBITMAP)SelectObject(BackBufDC, BackBitmap);

		SelectObject(OldDC, SaveBitmap);
		FillRect(OldDC, &Brt, (HBRUSH)GetStockObject(WHITE_BRUSH));
		FillRect(BackBufDC, &rt, (HBRUSH)GetStockObject(WHITE_BRUSH)); //도화지 색 변경
		/////////////////////////////////////////

		////////// DC에 초기 비트맵 저장/////////
		image = LoadPNG(g_hInst, MAKEINTRESOURCE(IDB_PNG1)); //빈공간 블록 이미지 저장 (Gdi)
		WBimage = LoadPNG(g_hInst, MAKEINTRESOURCE(IDB_PNG2));

		///////// 다음 나올 블록 비트맵 초기 설정 ////////
		hNextBlock = LoadBitmap(g_hInst, MAKEINTRESOURCE(NextColor));
		SelectObject(NextBDC, hNextBlock);
		////////////////////////////////////////////////

		////////맨 처음 나올 블록 비트맵 초기 설정 ////////
		hBlock = LoadBitmap(g_hInst, MAKEINTRESOURCE(NowColor)); //벽돌 이미지 저장
		SelectObject(hMemDC, hBlock); //hMemDC에 hBlock 비트맵 선택
		///////////////////////////////////////////////////
		hWhenR = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP12));
		SelectObject(WhenRandDC, hWhenR);
		BlackBitmap = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP12));
		SelectObject(BlackDC, BlackBitmap);
		hSagac = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP10)); //미리보기 창 이미지 저장 
		SelectObject(SagacDC, hSagac);
		BackGround = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP8)); //배경 이미지 저장
		SelectObject(BMemDC, BackGround);
		hOlMem = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BITMAP9)); //외곽선 이미지 저장 
		SelectObject(OLMemDC, hOlMem);
		////////////////////////////////////////
		InitBoard();
		SetTimer(hWnd, 1, Time1, NULL);

		Game_Start = 0; //초기화

		break;
	case WM_KEYDOWN:
		switch (wParam)
		{
		case VK_LEFT:
			CheckCols();
			if(L != 1)
				leftmove();
			break;
		case VK_RIGHT:
			CheckCols();
			if(R != 1)
				rightmove();
			break;
		case VK_UP:
			rotate();
			CheckCols();
			break;
		case VK_DOWN:
			if (IsKeyDown != 1)
			{
				SetTimer(hWnd, 4, 100, NULL);
				IsKeyDown = 1;
			}
			break;
		case VK_SPACE:  
			KillTimer(hWnd, 1);
			RightNowSelec(); //즉시 배치 
			break;
		}

		break;
	case WM_KEYUP:
		switch (wParam)
		{
			case VK_DOWN:
				if (IsKeyDown != 0)
					IsKeyDown = 0;
				KillTimer(hWnd, 4);
				if (CheckCols() != 1 && DownSecond >= 3)
				{
					KillTimer(hWnd, 2);
					SetTimer(hWnd, 1, Time1, NULL);
					DownSecond = 0;
				}
				break;
		}
		break;

	case WM_TIMER: //800ms 
		switch (wParam)
		{
		case 1:
			//CheckCols();
			if (CheckCols() == 1) //블럭 충돌 감지시 
			{
				SetTimer(hWnd, 3, 120, NULL);
			}
			else
			{
				Draw_Block(0);
				testArray();
				downmove();
				CheckCols();
			}
			break;

		case 2:
			if (CheckCols() != 1)
			{
				testArray();
				downmove();
				CheckCols();
			}
			break;	

		case 3:
			if (CheckCols() != 1)
			{
				Second = 0;
				KillTimer(hWnd, 3);
			}
			else
			{
				if (Second < 4) //바닥 닿은상태에서 좌우 움직일때 다 쓸어버리는거 해결해 이 시발럼아
				{
					CheckCols();
					Second++;
				}
				else //(Second == 4)
				{
					KillTimer(hWnd, 3);
					SelectBlock();
					IsLose();
					BitBlt(OldDC, 50, 50, 420, 600, BackBufDC, 50, 50, SRCCOPY);
					for (int i = 0; i < 10; i++)
						isfull();
					x = 230; y = 110;
					XOrig = x; YOrig = y;
					Down = 0;
					testArray();


					///////////// 블럭 정보 초기화////////////////
					Rand = NRand;
					MaxArray = NMaxArray;
					NRand = random(7);
					NMaxArray = 8 * (rand() % brickpatnum[NRand] + 1);

					NowColor = NextColor;
					NextColor = RandColor();
					hNextBlock = LoadBitmap(g_hInst, MAKEINTRESOURCE(NextColor));
					SelectObject(NextBDC, hNextBlock);
					hBlock = LoadBitmap(g_hInst, MAKEINTRESOURCE(NowColor));
					SelectObject(hMemDC, hBlock);
					//////////////////////////////////////////////

					DrawNextBlock();
					CheckCols();
					Second = 0;
					CantMove = 0;
				}
			}
			break;

		case 4: //Down키 타이머 
			DownSecond++;
			if (DownSecond >= 3)
			{
				KillTimer(hWnd, 1);
				SetTimer(hWnd, 2, Time2, NULL);
				KillTimer(hWnd, 4);
			}
			break;
		}

		return 0;
	case WM_CLOSE: //패배 시
		KillTimer(hWnd, 1);
		KillTimer(hWnd, 2);
		if(MessageBox(hWnd, End,(LPCWSTR)"End", MB_OK) == IDYES)
			return 0;
	case WM_DESTROY:
		f.close();
		if (image != NULL)
		{
			delete WBimage;
			delete image;
		}
		ReleaseDC(hWnd, hdc); //DC 해제 

		DeleteDC(NextBDC);
		DeleteDC(BackBufDC);
		DeleteDC(MemDC);
		DeleteDC(hMemDC);
		DeleteDC(BMemDC);
		DeleteDC(OLMemDC);
		DeleteDC(SagacDC);
		DeleteDC(OldDC);
		DeleteDC(CopyDC);
		DeleteDC(BlackDC);
		DeleteDC(WhenRandDC);

		DeleteObject(hWhenR);
		DeleteObject(BlackBitmap);
		DeleteObject(CopyBitMap);
		DeleteObject(SelectObject(BackBufDC, OldBitmap));
		DeleteObject(SaveBitmap);
		DeleteObject(hBlock);
		DeleteObject(hBlock2);
		DeleteObject(BackGround);
		DeleteObject(hOlMem);
		DeleteObject(hSagac);
		DeleteObject(hNextBlock);
		DeleteObject(BackBitmap);
		DeleteObject(OldBitmap);
		DeleteObject(MyBitmap);

		KillTimer(hWnd, 1);
		KillTimer(hWnd, 2);
		KillTimer(hWnd, 3);
		KillTimer(hWnd, 4);
		PostQuitMessage(0);

		/*
		HDC hdc, MemDC,NextBDC, hMemDC , BMemDC , OLMemDC, BackBufDC, SagacDC, OldDC; //DC
		HBITMAP MyBitmap, OldBitmap , BackBitmap , SaveBitmap; //비트맵 저장 핸들
		HBITMAP hBlock, hNextBlock, hBlock2, BackGround, hOlMem, hSagac; //블럭 이미지 저장 핸들
		*/
		return 0;

	case WM_PAINT:
		hdc = BeginPaint(hWnd, &ps);

		DrawScreen(); //블록을 제외한 모든 화면 출력
		Draw_Block(1); //블록 출력 1 = 블록 & 0 = 공백 블록 
		DrawNextBlock();
		Draw_AlphaBlock();
		TransparentBlt(BackBufDC, 50, 50, 420, 600, CopyDC, 50, 50, 420, 600,RGB(0,0,0)); //블럭 담는 DC를 hdc에 출력 
		BitBlt(hdc, 0, 0, FIXWID, FIXHID, BackBufDC, 0, 0, SRCCOPY);
		EndPaint(hWnd, &ps);
		break;
	}
	
	return(DefWindowProc(hWnd, iMessage, wParam, lParam));
}

void RightNowSelec() //즉시 배치 함수
{
	Draw_Block(0);
	for (int i = 0; i < HIDTH; i++)
	{
		if (CheckCols() != 1)
		{
			CleanAry();
			YOrig+=30;
			InsertAry();
		}
		else
		{
			InvalidateRect(hWnd, NULL, FALSE);
			Draw_Block(1);
			SelectBlock();
			IsLose();
			BitBlt(OldDC, 50, 50, 420, 600, BackBufDC, 50, 50, SRCCOPY);
			for (int i = 0; i < 10; i++)
				isfull();
			x = 230; y = 110;
			XOrig = x; YOrig = y;
			Down = 0;
			testArray();


			///////////// 블럭 정보 초기화////////////////
			Rand = NRand;
			MaxArray = NMaxArray;
			NRand = random(7);
			NMaxArray = 8 * (rand() % brickpatnum[NRand] + 1);

			NowColor = NextColor;
			NextColor = RandColor();
			hNextBlock = LoadBitmap(g_hInst, MAKEINTRESOURCE(NextColor));
			SelectObject(NextBDC, hNextBlock);
			hBlock = LoadBitmap(g_hInst, MAKEINTRESOURCE(NowColor));
			SelectObject(hMemDC, hBlock);
			//////////////////////////////////////////////

			DrawNextBlock();
			CantMove = 0;
			//CheckCols();
			break;
		}
		testArray();
	}
	SetTimer(hWnd,1,Time1,NULL);
}

void WhereBlock()
{
	Graphics WB(BackBufDC);
	int x, y;
	int xorig=0, yorig=0;

	for (int i = MaxArray - 8; i < MaxArray; i += 2)
	{
		x = xorig;
		y = yorig;
		x += (pat[Rand][i] * 30);
		y += (pat[Rand][i + 1] * 30);
		WB.DrawImage(WBimage, x,y, 0, 0, 30, 30, UnitPixel); //http://www.soen.kr/lecture/library/gdiplus/old/5-2.htm
	}
}

void Draw_Glass()
{
	Graphics Glass(BackBufDC);
	for (int i = 1; i < HIDTH-1; i++)
	{
		for (int j = 1; j < WIDTH - 1; j++)
		{
			if (Map[i][j] == 0)
				Glass.DrawImage(image, j*30+50, i*30+50, 30, 30);
		}
	}
	
}

void DrawScreen()
{
	BitBlt(BackBufDC, 40, 40, 440, 620, OLMemDC, 0, 0, SRCCOPY); //외곽선
	BitBlt(BackBufDC, 510, 40, 240, 240, SagacDC, 0, 0, SRCCOPY); //미리보기창
	BitBlt(BackBufDC, 50, 50, 420, 600, BMemDC, 0, 0, SRCCOPY);//배경 
	DrawNextBlock();
}

void testArray() //배열 확인용 함수
{
	f << IsKeyDown;
	f << " " << Down;
	for (int i = 0; i < HIDTH; i++)
	{
		for (int j = 0; j < WIDTH; j++)
		{
			f <<Map[i][j];
		
		}
		f << endl;
	}
	f << endl;
}

void DrawNextBlock() //다음 나올 블럭 출력 
{
	int X = 625, Y = 165;
	//hNextBlock = LoadBitmap(g_hInst, MAKEINTRESOURCE(RandColor()) ); //

	for (int i = NMaxArray - 8; i < NMaxArray; i += 2)
	{
		X += (pat[NRand][i] * 30);
		Y += (pat[NRand][i + 1] * 30);
		BitBlt(BackBufDC, X, Y, 30, 30, NextBDC, 0, 0, SRCAND);
		X = 625;
		Y = 165;
	}
}

void InitBoard() //배열 초기화 0 = 빈공간 1 = 벽 
{
	for (int i = 0; i < HIDTH; i++)
	{
		for (int j = 0; j < WIDTH; j++)
		{
			if (i == 0 || i == HIDTH - 1 || j == 0 || j == WIDTH - 1)
				Map[i][j] = 1;
			else
				Map[i][j] = 0;
		}
	}
}

void Draw_Block(int flag) //블럭 출력 함수  // brickpatnum[7] = { 2,1,2,2,4,4,4 };
{
	testArray();
	HDC B;
	B = GetDC(hWnd);

	if (flag == 1) //1이면 벽돌 0이면 투명 
	{
		B = hMemDC;
		for (int i = MaxArray - 8; i < MaxArray; i += 2)
		{
			x = XOrig;
			y = YOrig;
			x += (pat[Rand][i] * 30);
			y += (pat[Rand][i + 1] * 30);
			CheckCols();
			if (L != 1 || R != 1)
				BitBlt(CopyDC, x, y, 30, 30, B, 0, 0, SRCCOPY);
			else
				break;
		}
	}
	else
	{
		//Graphics g(BackBufDC); //Gdi Graphic 객체 g 선언후 dc 초기화
		B = BlackDC;
		for (int i = MaxArray - 8; i < MaxArray; i += 2)
		{
			x = XOrig;
			y = YOrig;
			x += (pat[Rand][i] * 30);
			y += (pat[Rand][i + 1] * 30);
			BitBlt(CopyDC, x, y, 30, 30, B, 0, 0, SRCCOPY);
			//g.DrawImage(image, x, y,30,30);
		}
	}
	
}

void Draw_AlphaBlock() //맵 전체에 투명블럭을 깔아준다. 
{
	x = 20; y = 50;
	Graphics g(BackBufDC); //Gdi Graphic 객체 g 선언후 dc 초기화
	/*Bitmap *pBitmap = image; //출력할 이미지 변수입니다
	Bitmap memBitmap(pBitmap->Width(), pBitmap->Height()); //가져온 이미지의 크기만큼 Bitmap 파일을 하나 만듭니다.
	Graphics memG(&memBitmap); //메모리에 그려줄 Graphics변수입니다.*/

	for (int j = 0; j < 20; j++)
	{
		for (int i = 0; i < 14; i++)
		{
			x += 30;
			g.DrawImage(image, x, y, 30, 30);
		}
		y += 30;
		x = 20;
	}
	x = 230; y = 110;

}

int CheckCols() //0 = 충돌X 1 = 충돌o 
{
	for (int i = HIDTH - 1; i > 0; i--)
	{

		for (int j = WIDTH - 1; j >= 0; j--)
		{
			if (Map[i][j] == 1 || Map[i][j] == 2) //벽이거나 설치된 블럭이면
			{
				if (Map[i - 1][j] == 3 && Down != 1)
				{
					Down = 1;
					return Down;
					//break;
				}
				else if (j != 15 && Map[i][j + 1] == 3 && L != 1)
					{
					L = 1;
					break;
				}
				else if (j != 0 && Map[i][j - 1] == 3 && R != 1)
				{
					R = 1;
					break;
				}
				else
				{
					L = 0, R = 0, Down = 0;
				}
			}
			
		}
		if ( L == 1 || R == 1)
			break;
	}

	return Down;
}

int RandColor()
{
	return  (rand() % 7 + 122); //resource.h의 리소스 번호에 따라 조정. 122~128 블럭
}

void downmove() //WM_TIMER의 timer 주기로 블록이 1칸씩 내려감.
{
	Draw_Block(0);
	InvalidateRect(hWnd, NULL, FALSE);
	CleanAry();
	YOrig += 30;
	InsertAry();
	Draw_Block(1);
	CheckCols();
}

void leftmove() //왼쪽으로 이동.
{
		CleanAry();
		Draw_Block(0);
		InvalidateRect(hWnd, NULL, FALSE);
		XOrig -= 30;
		InsertAry();
		CheckCols();
		Draw_Block(1);
		testArray();
}

void rightmove() //오른쪽으로 이동.
{
		CleanAry();
		Draw_Block(0);
		InvalidateRect(hWnd, NULL, FALSE);
		XOrig += 30;
		InsertAry();
		CheckCols();
		Draw_Block(1);
		testArray();
}

void CleanAry() //배열에 저장되있는 이동전의 블럭값을 없애준다.
{
	int X, Y;

	for (int i = MaxArray - 8; i < MaxArray; i += 2)
	{
		X = XOrig - 50;
		Y = YOrig - 50;
		X += (pat[Rand][i] * 30);
		Y += (pat[Rand][i + 1] * 30);
		X = X / 30 + 1;
		Y = Y / 30 + 1;
		Map[Y][X] = 0;

	}
}

void SelectBlock() //밑부분이 닿을시 3이던 값은 2로 바뀌며 고정됨.
{
	int X, Y;
	CantMove = 1;
	for (int i = MaxArray - 8; i < MaxArray; i += 2)
	{
		X = XOrig - 50;
		Y = YOrig - 50;
		X += (pat[Rand][i] * 30);
		Y += (pat[Rand][i + 1] * 30);
		X = (X / 30) + 1 ;
		Y = (Y / 30) + 1 ;
		Map[Y][X] = 2;
	}
}

void InsertAry() //블록값을 3으로 초기화 하여 이동중임을 나타낸다.
{
	int X, Y;
	for (int i = MaxArray - 8; i < MaxArray; i += 2)
	{
		X = XOrig - 50;
		Y = YOrig - 50;
		X += (pat[Rand][i] * 30);
		Y += (pat[Rand][i + 1] * 30);
		X = (X / 30) + 1;
		Y = (Y / 30) + 1;
		Map[Y][X] = 3;
	}
}

void DrawCharacter()
{

}

Image* LoadPNG(HMODULE hModule, LPCWSTR ResourceName) //PNG 파일을 리소스 파일에서 로드 하는 Gdi 함수 
{
	//http://m.blog.naver.com/totoru1219/220702210611 자세한 것은 다음 블로그 참고.

	Image* image = NULL;
	IStream* pStream = NULL;

	HRSRC hResource = FindResource(hModule, ResourceName, L"PNG"); //"PNG" 형식의 파일을 리소스파일에서 찾은 후 hResource에 반환
	if (CreateStreamOnHGlobal(NULL, TRUE, &pStream) == S_OK) {
		PVOID pResourceData = LockResource(LoadResource(hModule, hResource));
		DWORD imageSize = SizeofResource(hModule, hResource);
		DWORD dwReadWrite = 0;
		pStream->Write(pResourceData, imageSize, &dwReadWrite);
		image = Image::FromStream(pStream);
		pStream->Release();
	}
	return image;
}

void rotate() //블럭 회전 함수 
{
	if ((L == 0 && R == 0) && Down != 1)
	{
		Draw_Block(0);
		InvalidateRect(hWnd, NULL, FALSE);
		CleanAry();

		if (MaxArray / 8 == brickpatnum[Rand])
			MaxArray = 8;
		else
			MaxArray += 8;

		InsertAry();
		Draw_Block(1);
		
	}
}

int isfull() //1칸이 다 찼을시 비워줌.
{
	int i, j;
	int Count = 0;

	for (i = 1; i < HIDTH-1; i++)
	{
		for (j = 1; j < WIDTH-1; j++)
		{
			if (Map[i][j] == 2)
				Count++;
		}
		if (Count == 14)
		{
			DeleteLine = i;
			CleanLine();
		}
		else
			Count = 0;
	}
	return Count;
}

void CleanLine() //블럭이 다 채워진 줄을 지운후, 지운수만큼 윗 블럭들을 밑으로 내려준다.
{
	for(int j = 1; j < WIDTH-1; j++)
		Map[DeleteLine][j] = 0;

	for (int m = DeleteLine ; m > 1; m--) //HIDTH 22 
	{
		for (int n = 1; n < WIDTH - 1; n++)
		{
			BitBlt(CopyDC, n * 30 + 20, m * 30 + 20, 30, 30, CopyDC, n * 30 + 20, (m - 1) * 30 + 20, SRCCOPY);
			Map[m][n] = Map[m - 1][n];
		}
	}

	for (int k = 1; k < WIDTH - 1; k++)
		Map[1][k] = 0;
}

void IsLose() //패배 처리 
{
	for (int i = 1; i < WIDTH-2; i++)
	{
		if (Map[3][i] == 2)
		{
			SendMessage(hWnd, WM_CLOSE, 0, 0);
		}
	}
}

void Draw_Where()
{
	for (int i = 0; i < HIDTH; i++)
	{
		if (CheckCols() != 1)
		{
			CleanAry();
			YOrig += 30;
			InsertAry();
		}
		else
		{
			InvalidateRect(hWnd, NULL, FALSE);
			Draw_Block(1);
			break;
		}
	}
}
/*
void printstage()
void makenewblock()
void drawscreen()
void printscore()
*/

